
\chapter{Supported SQL}

This chapter describes the SQL syntax and extensions that \csvsqldb{} supports. As mentioned previously, not all SQL constructs make sense for a readonly non-persistent database and we have excluded or adapted features in order to work properly. However, \csvsqldb{} follows the SQL standard ISO/IEC 9075-2:2011 \cite{ISO_SQL_Standard} as closely as possible wherever applicable. So, with minimal standard SQL knowledge you should be able to use \csvsqldb{} to your advantage, as most of the SQL will look very familiar.

\section{SQL Syntax}
We describe the SQL syntax using so called syntax diagrams \cite{Wikipedia_Syntaxdiagram}. In general the syntax can be understood much easier using these kind of diagrams rather than using EBNF grammars, which are much harder to decipher.

\begin{SyntaxGrammar}{SELECT\_STMT}{selectstmt}
\matrix[row sep=1mm,column sep=2mm] {
% First row:
& & & & & & & & & \node (comma) [terminal] {,}; & & & & \\
% Second row:
\node (p1) [startpoint] {}; & \node (select) [terminal] {SELECT};                                          &
\node (p2) [point] {}; &                                                                                                      &
\node (p3) [point] {}; & \node (select list) [nonterminal] {SELECT\_LIST};                            &
\node (p4) [point] {}; & \node (from) [terminal] {FROM};                                                     &
\node (p5) [point] {}; & \node (table reference) [nonterminal] {TABLE\_REFERENCE};           &
\node (p6) [point] {}; & \node (table expressions) [nonterminal] {TABLE\_EXPRESSIONS};    &
\node (p7) [point] {}; & \node (p8) [endpoint] {}; \\
% Third row:
& & & \node (distinct) [terminal] {DISTINCT}; & & & & & & & & & &  \\
% Fourth row:
& & & \node (all) [terminal] {ALL}; & & & & & & & & & & \\
};

\graph [use existing nodes] {
  p1 -> select -- p3 -> select list -> from -> table reference -> table expressions -- p7 -> p8;
  distinct <-[hv path] p2;
  p3 <-[vh path] distinct;
  all <-[hv path] p2;
  p3 <-[vh path] all;
  comma ->[hv path] p5;
  p6 ->[vh path] comma;
};
\putendline{p8}
\end{SyntaxGrammar}

\begin{SyntaxGrammar}{SELECT\_LIST}{selectlist}
\matrix[row sep=1mm,column sep=2mm] {
% First row:
& & & & & \node (comma) [terminal] {,}; & & & & \\
% Second row:
\node (p1) [startpoint] {}; & \node (p2) [point] {}; & \node (asterisk) [terminal] {ASTERISK}; &
&  &                                                                                    &
&  &                                                                                    &
& \node (p5) [point] {}; & \node (p6) [point] {}; & \node (p7) [endpoint] {}; \\
% Third row:
& & \node (expression) [nonterminal] {EXPRESSION}; & \node (p3) [point] {}; & & & & & & \\
% Fourth row:
& & &  &  & &  \node (p4) [point] {}; & \node (identifier) [nonterminal] {IDENTIFIER}; & & \\
% Fifth row:
& & & &  & \node (as) [terminal] {AS}; & & & & \\
};

\graph [use existing nodes] {
  p1 -- p2 -> asterisk  -- p5 -- p6 -> p7;
  expression <-[hv path] p2;
  p5 <-[vh path] expression;
  p5 <-[vh path] identifier;
  identifier <-[hv path] p3;
  as <-[hv path] p3;
  p4 <-[vh path] as;
  p5 ->[vh path] comma;
  comma ->[hv path] p2;
};
\putendline{p7}
\end{SyntaxGrammar}

\begin{SyntaxGrammar}{TABLE\_REFERENCE}{tablereference}
\matrix[row sep=1mm,column sep=2mm] {
% First row:
\node (p1) [startpoint] {}; & \node (tableorsubselect) [nonterminal] {TABLE\_OR\_SUBSELECT}; & 
\node (p2) [point] {}; & & & & & & & & &
\node (p5) [point] {}; & &
\node (p6) [endpoint] {}; \\
% Second row:
 & & \node (p9) [point] {}; & & \node (join type) [nonterminal] {JOIN\_TYPE}; &
 \node (tableorsubselect2) [nonterminal] {TABLE\_OR\_SUBSELECT}; &
 \node (p3) [point] {}; & \node (on) [terminal] {ON}; & \node (expression) [nonterminal] {EXPRESSION}; &
 \node (p4) [point] {}; & & & \\
% Third row:
 & & & & &  & & & & & & & & \\
 & & & & & & & \node (p7) [point] {}; & & & & & \\
% Fourth row:
 & & & & &  & & & & & & & & \\
 & & & & & \node (p8) [point] {}; & & & & & & & \\
};

\graph [use existing nodes] {
  p1 -> tableorsubselect -- p2 -- p5 -> p6;
  p2 ->[vh path] join type -> tableorsubselect2 -- p3 -> on -> expression -- p4 ->[hv path] p5;
  p3 ->[vh path] p7 ->[hv path] p5;
  p5 ->[vh path] p8 ->[hv path] p9;
};
\putendline{p6}
\end{SyntaxGrammar}

\begin{SyntaxGrammar}{TABLE\_OR\_SUBSELECT}{tableorsubselect}
\matrix[row sep=1mm,column sep=2mm] {
% First row:
\node (p1) [startpoint] {}; &
\node (p2) [point] {}; & \node (identifier) [nonterminal] {IDENTIFER}; & & &
\node (p3) [point] {}; & \node (p4) [point] {}; & & & &
\node (p6) [point] {}; & 
\node (p7) [point] {}; & &
\node (p8) [endpoint] {}; \\
% Second row:
 & & \node (lparen) [terminal] {(}; & 
\node (select stmt) [nonterminal] {SELECT\_STMT}; & 
\node (rparen) [terminal] {)}; & & & & \node (p5) [point] {}; &
\node (alias) [nonterminal] {IDENTIFER}; & & & & \\
% Third row:
& & & & & & & \node (as) [terminal] {AS}; & & & & & \\
};

\graph [use existing nodes] {
  p1 -- p2 -> identifier -- p3 -- p4 --p6 -- p7 -> p8;
  p2 ->[vh path] lparen -> select stmt -> rparen ->[hv path] p3;
  p4 ->[vh path] as ->[hv path] p5;
  p4 --[vh path] p5 -> alias ->[hv path] p6;
};
\putendline{p8}
\end{SyntaxGrammar}

\begin{SyntaxGrammar}{JOIN\_TYPE}{jointype}
\matrix[row sep=1mm,column sep=2mm] {
% First row:
\node (p1) [startpoint] {}; & 
\node (p2) [point] {}; & 
\node (cross) [terminal] {CROSS}; & &
\node (p3) [point] {}; & & & & & & & \node (p9) [point] {}; & & \node (join) [terminal] {JOIN}; & & \node (p13) [endpoint] {}; \\
% Second row:
 & & \node (inner) [terminal] {INNER}; & & & & & & & & & & & \\
% Third row:
 & \node (p11) [point] {}; & \node (natural) [terminal] {NATURAL}; & \node (p10) [point] {}; &
 \node (p4) [point] {}; & 
 \node (left) [terminal] {LEFT}; & 
 \node (p7) [point] {}; & \node (p5) [point] {}; & &
 \node (p6) [point] {}; & \node (p8) [point] {}; & & & & \\
% Fourth row:
 & & \node (p12) [point] {}; & & & \node (right) [terminal] {RIGHT}; & & & \node (outer) [terminal] {OUTER}; & & & & & & \\
% Fifth row:
 & & & & & \node (full) [terminal] {FULL}; & & & & & & & & & \\
% Sixth row:
 & & & & & \node (inner2) [terminal] {INNER}; & & & & & & & & & \\
};

\graph [use existing nodes] {
  p1 -> cross -> join -> p13;
  p2 ->[vh path] inner ->[hv path] p3;
  p2 ->[vh path] natural -> left ->[hv path] p9;
  p4 ->[vh path] right ->[hv path] p7;
  p4 ->[vh path] full ->[hv path] p7;
  p4 ->[vh path] inner2 ->[hv path] p8;
  p5 ->[vh path] outer ->[hv path] p6;
  p11 --[vh path] p12 ->[hv path] p10;
};
\putendline{p13}
\end{SyntaxGrammar}

\begin{SyntaxGrammar}{TABLE\_EXPRESSION}{tableexpressions}
\matrix[row sep=1mm,column sep=2mm] {
% First row:
\node (p1) [startpoint] {}; & &
\node (p2) [point] {}; & & 
\node (where) [terminal] {WHERE}; & & & \node (where expression) [nonterminal] {EXPRESSION}; &
\node (p3) [point] {}; & & & & & & & &  \\
& & & & & & & & & & \\
& & & & \node (p10) [point] {}; & & & & & & \\
& & & & & & & & & & \\
% Second row:
& & \node (p31) [point] {}; & \node (p5) [point] {}; &
\node (group) [terminal] {GROUP}; & 
\node (group by) [terminal] {BY}; & 
\node (p6) [point] {}; & & \node (p11) [point] {}; & & & \node (group identifier) [nonterminal] {IDENTIFIER\_LIST}; &
\node (p7) [point] {}; & &
 & \\
& & & & & & & \node (distinct) [terminal] {DISTINCT}; & & & & \\
&  & & & & & & \node (all) [terminal] {ALL}; & & & & \\
% Third row:
& & & & & & & & & & \\
& & & & & \node (p12) [point] {}; & & & & & & \\
& & & & & & & & & & \\
& & \node (p28) [point] {}; & \node (p14) [point] {}; &
\node (having) [terminal] {HAVING}; & & & \node (having expression) [nonterminal] {EXPRESSION}; &
\node (p15) [point] {}; & & & & & &  & \\
% Fourth row:
& & & & & & & & & & \\
& & & & & \node (p17) [point] {}; & & & & & & \\
& & & & & & & & & & \\
& & \node (p29) [point] {}; & \node (p18) [point] {};  &
\node (order) [terminal] {ORDER}; & 
\node (order by) [terminal] {BY}; & 
\node (p19) [point] {}; & & \node (p20) [point] {}; & & & \node (order identifier) [nonterminal] {IDENTIFIER\_LIST}; &
\node (p21) [point] {}; & 
& \\
& & & & & & & \node (asc) [terminal] {ASC}; & & & & \\
& & & & & & & \node (desc) [terminal] {DESC}; & & & & \\
% Fifth row:
& & & & & & & & & & \\
& & & & & \node (p23) [point] {}; & & & & & & \\
& & & & & & & & & & \\
& & \node (p30) [point] {}; & \node (p24) [point] {};  &
\node (limit) [terminal] {LIMIT}; & & & \node (limit expression) [nonterminal] {EXPRESSION}; & \node (p27) [point] {};
 & & & & \node (p25) [point] {}; & &  & \\
& & & & & & & & & & \node (offset) [terminal] {OFFSET}; & \node (offset expression) [nonterminal] {EXPRESSION}; &  \\
& & & & & & & & & & \\
& & & & & & & & & & & & & & \node (p13) [endpoint] {}; \\
};

\graph [use existing nodes] {
  p1 -> where -> where expression -> p3;
  p3 --[vh path] p10 --[hv path] p5 -> group -> group by -> group identifier;
  p6 ->[vh path] distinct ->[hv path] p11;
  p6 ->[vh path] all ->[hv path] p11;
  p7 --[vh path] p12 --[hv path] p14 -> having -> having expression;
  p15 --[vh path] p17 --[hv path] p18 -> order -> order by -> order identifier;
  p19 ->[vh path] asc ->[hv path] p20;
  p19 ->[vh path] desc ->[hv path] p20;
  p21 --[vh path] p23 --[hv path] p24 -> limit -> limit expression;
  p27 ->[vh path] offset -> offset expression ->[hv path] p25;
  group identifier -- p7;
  having expression -- p15;
  order identifier -- p21;
  limit expression ->[hv path] p13;
  p2 -> p31 -> p28 -> p29 -> p30;
  p31 -- p5;
  p28 -- p14;
  p29 -- p18;
  p30 -- p24;
  p24 ->[vh path] p13;
};
\putendline{p13}
\end{SyntaxGrammar}

\section{Data Types}
\csvsqldb{} has an ample set of datatypes. Type operations can be performed on data types. Data types can also be converted.

\begin{FseTabular}{Data Types}{p{3.5cm}p{7.5cm}}{data_types}
\textbf{Type} & \textbf{Summary} \\
\midrule
BOOL & TRUE, FALSE, or UNKNOWN \\
BOOLEAN & Same as BOOL \\
INT & Signed 64-bit integer \\
INTEGER & Same as INT \\
FLOAT & IEEE 754 64-bit floating point number \\
DOUBLE & Same as FLOAT \\
REAL & Same as FLOAT \\
VARCHAR & Variable character string \\
CHAR & Single character \\
CHARACTER & Same as CHAR \\
DATE & Date \\
TIME & Time \\
TIMESTAMP & Timestamp \\
\end{FseTabular}

\subsection{Operations on Data Types}

\subsubsection{Boolean}

\begin{FseTabular}{Boolean Operations}{p{3.5cm}p{3.0cm}p{3.0cm}p{4.0cm}}{data_types}
\textbf{Operator} & \textbf{Kind} & \textbf{Resulting Type} & \textbf{Description} \\
\midrule
\end{FseTabular}

\subsubsection{Integer}

\subsubsection{Real}

\subsubsection{Character String}

\subsubsection{Date}

\subsubsection{Time}

\subsubsection{Timestamp}

\subsection{Conversion Matrix}

\section{Functions}

\subsection{Aggregation Functions}

Functions that aggregate rows.

\begin{FseTabular}{Aggregation Functions}{p{3.5cm}p{7.5cm}p{3.5cm}}{aggr_functions}
\textbf{Function Name} & \textbf{Summary} & \textbf{Category} \\
\midrule
SUM & Calculates the rows sum & Math Functions \\
MIN & Calculates the rows min value & Math Functions \\
MAX & Calculates the rows max value & Math Functions \\
AVG & Calculates the rows average  & Math Functions \\
COUNT & Returns the number of rows & General \\
ARBITRARY & Returns some row non-NULL value & General \\
\end{FseTabular}

\subsection{General Functions}

General functions.

\begin{FseTabular}{Build-In Functions}{p{3.5cm}p{7.5cm}p{3.5cm}}{functions}
\textbf{Function Name} & \textbf{Summary} & \textbf{Category} \\
\midrule
CAST & Cast to another type & Conversion \\
CHARACTER\_LENGTH & Returns the length in byte of the given string & String Manipulation \\
CHAR\_LENGTH & Returns the length in byte of the given string & String Manipulation \\
CURRENT\_DATE & Returns the current date & Date \& Time Functions\\
CURRENT\_TIME & Returns the current time in the local timezone & Date \& Time Functions \\
CURRENT\_TIMESTAMP & Returns the current time in the local timezone & Date \& Time Functions \\
DATE\_FORMAT & Formats a date according to the specified pattern & Date \& Time Functions \\
DATE\_TRUNC & Truncates the given timestamp according to the specified precision & Date \& Time Functions \\
EXTRACT & Extracts the specified parts from a timestamp & Date \& Time Functions \\
LOWER & Converts the given string to lower case & String Manipulation \\
POW & Returns the number raised to the specified power & Math Functions \\
TIMESTAMP\_FORMAT & Formats a timestamp according to the specified pattern & Date \& Time Functions \\
TIME\_FORMAT & Formats a time according to the specified pattern & Date \& Time Functions \\
UPPER & Converts the given string to upper case & String Manipulation \\
VERSION & Returns the version of the \csvsqldb{} & Misc \\
\end{FseTabular}

\section{Restrictions}
